/*
 https://leetcode.com/problems/k-inverse-pairs-array/?envType=daily-question&envId=2024-01-27
*/

#include <iostream>
#include <vector>
#include <map>

using namespace std;

class Solution
{
public:
    int kInversePairs(int n, int k)
    {
        auto dp = vector<vector<int>>(n + 1, vector<int>(k + 1, 0));
        int mod = 1000000007;
        for(int i = 0; i <= n; ++i)
            dp[i][0] = 1;

        for(int i = 2; i <= n; ++i)
        {
            for (int j = 1; j <= k; ++j)
            {
                dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % mod;
                if( j >= i )
                    dp[i][j] = (mod + dp[i][j] - dp[i - 1][j - i]) % mod;
            }
        }
        return dp[n][k];
    }
};


int main()
{
    cout << Solution().kInversePairs(3, 2) << endl;
    cout << Solution().kInversePairs(3, 1) << endl;
    cout << Solution().kInversePairs(3, 0) << endl;
    cout << Solution().kInversePairs(1000, 1000) << endl;


}

/*
 Main idea:
 Якщо розглянути випадок n = 3, k = 2, то всі варіанти масиву розміром 3
 виглядатиметь так:
 (1, 2, 3), (1, 3, 2), (3, 1, 2), (3, 2, 1), (2, 1, 3), (2, 3, 1)
 То для k = 2 нам підійдуть 2 варіанти:
 (2, 3, 1) та (2, 1, 3)

 Для побудови всіх варіантів нам потрібні лише параметри n та k і створюватимемо
 масив покроково вибираючи лише перший варіант за ітерацію.
 У масиві розміром 3 може бути 3 різні перші елементи.
 Вважатимемо, що масив містить неповторюючі елементи від 1 до n включно, тоді
 якщо ми оберемо 1 елементом число 1, то наразі є як мінімум 0 інверсій після
 нього. Якщо оберемо число 2, то буде точно 1 інверсія, бо дальше ще залишиться
 число 1. Якщо оберемо число 3, то отримуємо мінімум 2 інверсії. Таким чином
 на наступни ітераціях ми будуватимемо масив з 2 елементів, а кількість необхідних
 інверсій зміниться у залежності від того, яке число було обрано на попередньому кроці.
 Якщо для цього будувати дерево, то можна отримати таке(1 елемент n, 2 k)

                                 (3, 2)
                    (2, 0)       (2, 1)       (2, 2)
                             (1, 0)  (1, 1) (1, 1) (1, 2)

 Коли доходимо до k = 0, то отримуємо базовий випадрк, оскільки з 0 інверсіями в незалежності
 від n є лише 1 такий можливий масив, який відсортований в несправдному порядку.
 У нащому дереві таких базових випадки 2, тому й результатом буде 2.є

 Спосіб бектрекингу в цьому завданні є не ефективним, тому розгянемо варіант з динамікою, оскільки
 можна представити ці всі можливі випадки як масив розміро n + 1 на k + 1, де індекс n та k буде
 відповідати за кількість таких масивів з розміром n, у яких кількість інверсій рівна k.

 Подивившись на дерево можна можна побачити, що від верщини з розміром масиву n іде n синів, тобто
 для dp[n][k] результатом буде сума можливих масивів розміром n - 1, які мають кількість можливих
 інверсій від k - n - 1 до k. Один з варіантів це просто ітеруватись по цих синах, але в такому
 випадку складність роботи алгоритму буде О(n^2 * k), його можна оптимізувати, якщо розгялунути
 цей варіант, як sliding window, оскільки на рівні n ми сунемось по k елементах рівня n - 1 з
 "вікном" розміром n. Тому для dp[n][k] кількість можливих таких масивів буде як у dp[n][k-1]
 у сумі з з меншим масивом на 1, з такою ж кількістю інверсій. Якщо кількість можливих інверсій
 є більшою за розмір масиву, то необхідно відняти від dp[n][k] dp[n-1][k-n], оскільки такий варіант
 побудувати неможливо.

 Часова складність алгоритму: O(nk)

 Можна оптимізувати використання пам'яті, якщо використовувати не 2d масив, а лише 2 масиви розміром
 k, оскільки нам для поточної довжини масиву лише цікавлять випадки для масиву розміром на 1 менший
 від поточного. Тоді space complexity з O(nk) оптимізується до O(k).

 https://www.youtube.com/watch?v=dglwb30bUKI&t=1141s
*/