/*
 https://leetcode.com/problems/minimum-number-of-operations-to-make-array-empty/?envType=daily-question&envId=2024-01-04
*/

#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

class Solution
{
public:
    int minOperations(vector<int>& nums)
    {
        unordered_map<int, int> numOccurrences;
        int res = 0;

        for(int num : nums)
            numOccurrences[num]++;

        for(auto num : numOccurrences)
        {
            if( num.second == 1 )
                return -1;

            if ( !(num.second % 3) )
                res += num.second / 3;
            else if ( num.second % 3 == 1)
                res += (num.second - 4) / 3 + 2;
            else
                res += (num.second - 2) / 3 + 1;
        }

        return res;
    }
};

int main()
{
    Solution solution;

    vector<int> test1 = {2, 3, 3, 2, 2, 4, 2, 3, 4};
    vector<int> test2 = {2, 1, 2, 2, 3, 3};

    cout << solution.minOperations(test1) << endl;
    cout << solution.minOperations(test2) << endl;
}

/*
 Main idea:

 Спершу проходимось по масиву та рахуємо кількість входжень кожного із чисел.
 Ці значення записуються в мапу.
 Дальше в циклі перевіряємо кількість входжень кожного числа і за скільки ітерацій
 його можна видалити. Якщо в масиві число i зустрічається лише один раз, то таке
 число неможливо видалити за умовою, тому повертається -1.
 Якщо число зустрічається більше ніж 1 раз, тоді буде виконана процедура підрахунку
 ітерацій використовуючи операцію ділення кількості входжень на 3 за модулем.
 Тоді ймовірні три варіанти:

 - Остача 0: тоді це число можна видалити об'єднавши його в трійки за Occurrences / 3
 операції.
 - Остача 1: число можна видалити комбінуючи його об'єднання в пари та трійки, щоб
 кількість операцій видалення було якомога менше, то необхідно мінімізувати кількість
 пар. Найменша кількість пар, щоб можна було виконати таку операцію буде 2, тому необхідно
 зробити (Occurrences - 4) / 3 + 4 / 2 або ж (Occurrences - 4) / 3 + 2 операції
 - Остача 2: тоді як і у випадку з остачою на 4 необхідно розбити всі повторюючі числа на
 пари та трійки, але в цьому випадку найменша кількість пар для оптимального розв'язку буде
 лише 1. Тому необхідно зробити (Occurrences - 2) / 3 + 1 операцію.

 Які проблеми цього коду?
 Тут присутньо багато магічних чисел, які не розбірливі без пояснень вище, варто написати
 такі математичні операції, які містили б набагато менше подібних чисел.

*/